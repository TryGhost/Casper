<!-- style overrides for Leaflet -->
<link rel="stylesheet" href="{{asset 'map.css'}}">
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<!-- MAP CONTAINTER -->
        <article class="post-full leaflet-map-template">
            <div id="map" style="height: 100vh;"></div>
            <div class="map-data-container">{{content}}</div>
        </article>


<!-- Leaflet Script -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="{{asset "js/leaflet-custom-icons.js"}}"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
  // Only initialize the map if the map element exists
  // (it won't exist for members/paid content if the user doesn't have access)
  const mapElement = document.getElementById('map');
  if (!mapElement) return;

  const imageUrl = "{{feature_image}}";
  
  // Get video overlay from meta tag if it exists
  const overlayMeta = document.querySelector('meta[name="custom:overlay"]');
  const overlayFileName = overlayMeta ? overlayMeta.getAttribute('content') : null;
  const videoUrl = overlayFileName ? `/assets/images/overlays/${overlayFileName}` : null;
  
  // Get opacity from meta tag if it exists, otherwise default to 0.6
  const opacityMeta = document.querySelector('meta[name="custom:opacity"]');
  const opacity = opacityMeta ? parseFloat(opacityMeta.getAttribute('content')) : 0.6;

  const img = new Image();
  img.onload = function () {
    const w = this.naturalWidth;
    const h = this.naturalHeight;

    // Full image bounds
    const imageBounds = [[0, 0], [h, w]];

    // Create the map
    const map = L.map("map", {
      crs: L.CRS.Simple,
      preferCanvas: true,
      minZoom: -5,
      maxZoom: 2,
      zoomSnap: 0,
      zoomDelta: 0.25,
      maxBounds: imageBounds
    });

    // Add the image
    L.imageOverlay(imageUrl, imageBounds).addTo(map);
    
    // Add video overlay (ie. clouds) only if videoUrl exists
    if (videoUrl) {
      const videoOverlay = L.videoOverlay(videoUrl, imageBounds, {
        autoplay: true,
        loop: true,
        muted: true,
        opacity: opacity,
        keepAspectRatio: false
      }).addTo(map);
      
      // Function to disable picture-in-picture
      function disablePiP() {
        try {
          const videoElement = videoOverlay.getElement();
          if (videoElement) {
            // Set the attribute
            videoElement.disablePictureInPicture = true;
            
            // Also add the attribute directly to the DOM element
            videoElement.setAttribute('disablePictureInPicture', '');
          }
        } catch (e) {
          console.error("Error disabling picture-in-picture:", e);
        }
      }
      
      // Try immediately
      disablePiP();
      
      // Also try after a short delay to ensure the video is loaded
      setTimeout(disablePiP, 100);
    }
    
    // Get viewport height and calculate scale to fit height
    const viewportHeight = window.innerHeight;
    const scale = viewportHeight / h;
    const zoom = Math.log2(scale);

    // Clamp to allowed zooms
    const clampedZoom = Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), zoom));

    map.setView([h / 2, w / 2], clampedZoom);
    
    // Process map data from post content
    processMapData(map, h, w);

  };

  img.src = imageUrl;
  
  /**
   * Process map data from post content
   * Looks for JSON data in the post content and adds markers and other overlays to the map
   */
  function processMapData(map, imageHeight, imageWidth) {
    const mapDataContainer = document.querySelector('.map-data-container');
    if (!mapDataContainer) return;
    
    try {
      // Find all pre elements that might contain JSON data
      const preElements = mapDataContainer.querySelectorAll('pre');
      
      preElements.forEach(pre => {
        try {
          // Try to parse the content as JSON
          const content = pre.textContent.trim();
          if (!content.startsWith('{') && !content.startsWith('[')) return;
          
          const mapData = JSON.parse(content);
          
          // Process the map data
          if (mapData) {
            // Process markers
            if (mapData.markers && Array.isArray(mapData.markers)) {
              mapData.markers.forEach(marker => {
                if (marker.position && Array.isArray(marker.position) && marker.position.length === 2) {
                  // Convert coordinates to match the image coordinate system if needed
                  const y = marker.position[0];
                  const x = marker.position[1];
                  
                  let markerOptions = {};
                  
                  // Apply custom icon if specified
                  if (marker.icon) {
                    markerOptions.icon = L.icon(marker.icon);
                  } else if (marker.iconType && window.customIcons && window.customIcons[marker.iconType]) {
                    // Use predefined custom icon if iconType is specified
                    markerOptions.icon = window.customIcons[marker.iconType];
                  }
                  
                  // Create the marker
                  const m = L.marker([y, x], markerOptions).addTo(map);
                  
                  // Add popup if specified
                  if (marker.popup) {
                    m.bindPopup(marker.popup);
                  }
                  
                  // Add tooltip if specified
                  if (marker.tooltip) {
                    m.bindTooltip(marker.tooltip);
                  }
                }
              });
            }
            
            // Process polylines
            if (mapData.polylines && Array.isArray(mapData.polylines)) {
              mapData.polylines.forEach(polyline => {
                if (polyline.points && Array.isArray(polyline.points)) {
                  const options = polyline.options || {};
                  L.polyline(polyline.points, options).addTo(map);
                }
              });
            }
            
            // Process polygons
            if (mapData.polygons && Array.isArray(mapData.polygons)) {
              mapData.polygons.forEach(polygon => {
                if (polygon.points && Array.isArray(polygon.points)) {
                  const options = polygon.options || {};
                  L.polygon(polygon.points, options).addTo(map);
                }
              });
            }
            
            // Process circles
            if (mapData.circles && Array.isArray(mapData.circles)) {
              mapData.circles.forEach(circle => {
                if (circle.center && Array.isArray(circle.center) && circle.center.length === 2 && circle.radius) {
                  const options = circle.options || {};
                  L.circle(circle.center, { radius: circle.radius, ...options }).addTo(map);
                }
              });
            }
            
            // Process rectangles
            if (mapData.rectangles && Array.isArray(mapData.rectangles)) {
              mapData.rectangles.forEach(rectangle => {
                if (rectangle.bounds && Array.isArray(rectangle.bounds) && rectangle.bounds.length === 2) {
                  const options = rectangle.options || {};
                  L.rectangle(rectangle.bounds, options).addTo(map);
                }
              });
            }
            
            // Process custom view settings
            if (mapData.view) {
              if (mapData.view.center && Array.isArray(mapData.view.center) && mapData.view.center.length === 2) {
                const zoom = mapData.view.zoom !== undefined ? mapData.view.zoom : map.getZoom();
                map.setView(mapData.view.center, zoom);
              }
            }
          }
        } catch (e) {
          console.error('Error parsing map data JSON:', e);
        }
      });
    } catch (e) {
      console.error('Error processing map data:', e);
    }
  }
});

// Enable debug info with a query parameter
if (window.location.search.includes('debug=true')) {
  document.querySelector('.debug-info').style.display = 'block';
}
</script>
